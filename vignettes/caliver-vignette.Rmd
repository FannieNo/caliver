---
title: "caliver: CALIbration and VERification of gridded model outputs"
author: ""
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE}
knitr::opts_chunk$set(
  comment = '#>',
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  eval = FALSE
)
```

The package [caliver](https://cran.r-project.org/package=caliver) contains utility functions for the post-processing, calibration and validation of gridded model outputs. Initial test cases include the outputs of the following forest fire models: GEFF and RISICO.

## Dependencies and installation

Install [cdo](https://code.zmaw.de/projects/cdo/wiki) and the following packages before attempting to install caliver:

```{r}
packs <- c("devtools", "rgdal", "sp", "leaflet", "testthat", "knitr", "rmarkdown")
new.packages <- packs[!(packs %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
```

Get the development version from github using [devtools](https://github.com/hadley/devtools):

```{r}
devtools::install_github("anywhereProject/caliver")
```

Load the caliver package:

```{r}
library("caliver")
```

## Set working directory
Define the data folder, where the results will be stored
```{r}
setwd("/var/tmp/moc0/geff/results")
```

## Workflow type A: decompress-merge single variable files and calculate CDF and quantiles
Define the data folder and decompress all the files in a given folder (from *.nc.gz to *.nc)
```{r}
decompressGZ(dirs = "/var/tmp/moc0/forestfire", keep = FALSE)
```

Merge all the files (with name starting with *startingString*) over the time dimension
```{r}
mergedFile <- mergetime(dirs = "/var/tmp/moc0/forestfire", 
                        startingString = "geff_reanalysis_an_fwis_fwi_")
```

In order to conveniently plot the results, this map should be shifted 
```{r}
# shift the file horizontally
shiftedFile <- shiftMap(inFile = mergedFile, 
                        outFile = paste0(tools::file_path_sans_ext(mergedFile),
                                         "_shifted.nc"))
```

Get maps for given quantiles
```{r}
listOfMaps <- getGriddedCDF(ncfile = shiftedFile, 
                            varname = "fwi", 
                            probs = c(50, 75, 90, 99))
```

Plot maps
```{r}
plotPercentiles(listOfMaps)
```

## Workflow type B: extract variable from multi-variable files, calculate CDF and quantiles
Define the data folder
```{r}
setwd("/var/tmp/moc0/geff/results/")
dirs <- "/var/tmp/moc0/geff/data/"
myVar <- "fwi"
ncfile <- paste0(myVar,".nc")
```

Merge all the files (with name starting with *startingString*) over the time dimension
```{r}
mergedFile <- mergetime(dirs = dirs,
                        varname = myVar, 
                        startingString = "",
                        recursive = TRUE, 
                        outFile = ncfile)
```

In order to conveniently plot the results, this map should be shifted
```{r}
# shift the file horizontally
shiftedFile <- shiftMap(inFile = ncfile, 
                        outFile = paste0(tools::file_path_sans_ext(ncfile),
                                         "_shifted.nc"))
```

Calculate CDF and percentiles
```{r}
listOfMaps <- getGriddedCDF(shiftedFile)
```

Plot maps
```{r}
plotPercentiles(listOfMaps)
```

## Workflow type C: plot from pre-calculated percentiles in nc files
Define the working directory
```{r}
setwd("/var/tmp/moc0/geff/results/")
```

List all the files to plot
```{r}
ifiles <- c("fwi_shifted_50.nc", "fwi_shifted_75.nc", 
            "fwi_shifted_90.nc", "fwi_shifted_99.nc")
```

In order to conveniently plot the results, this map should be shifted
```{r}
# Generate a raster stack
listOfMaps <- raster::stack(ifiles)
```

Plot maps
```{r}
p <- rasterVis::levelplot(listOfMaps, 
                          col.regions = rev(grDevices::heat.colors(20)),
                          colorkey = list(space = "right"))
# Define a background map
backgroundMap <- rworldmap::getMap(resolution = "low")
p + latticeExtra::layer(sp::sp.lines(backgroundMap, lwd=0.8, col='darkgray'))
```

## Workflow type D: mask unrealistic values
In absence of vegetation the risk of ignition reduces to zero, regardless of the state of the soil.
To exclude these areas (deserts, glaciers, etc.) we apply a mask to the raster map of percentiles calculated above.

We identify non-vegetated areas using the fuel_model map provided by JRC. 
```{r}
shiftMap(inFile = "/var/tmp/moc0/geff/clim_fuelmodel.nc_ggN256")
fuelmodel <- raster::raster("/var/tmp/moc0/geff/clim_fuelmodel.nc_ggN256_shifted.nc")
rasterVis::levelplot(fuelmodel)
```
In this map, water-barren-marsh-Snow and Ice-Urban-Agriculture-NoData are identified by the codes 21-27. Therefore we assume all the values from 0 to 20 are valid, above 21 should be masked.
```{r}
fuelmodel[fuelmodel > 20] <- NA
rasterVis::levelplot(fuelmodel)
# Looks good! This file is also saved in the data folder of this package
# save(fuelmodel, file = "/home/mo/moc0/Repositories/caliver/data/fuelmodel.rda")
# data("fuelmodel")
```

This layer can be used to mask any other raster, for instance the maps of fwi-dc-ffmc percentiles. Here is an example to mask fwi\_shifted
```{r}
ifiles <- c("fwi_shifted_50.nc", "fwi_shifted_75.nc", 
            "fwi_shifted_90.nc", "fwi_shifted_99.nc")
listOfMaps <- raster::stack(ifiles)
maskedMaps <- raster::mask(listOfMaps, fuelmodel)

p <- rasterVis::levelplot(maskedMaps, 
                          col.regions = rev(grDevices::heat.colors(20)),
                          colorkey = list(space = "right"), 
                          names.attr = ifiles)
# Define a background map
backgroundMap <- rworldmap::getMap(resolution = "low")
p + latticeExtra::layer(sp::sp.lines(backgroundMap, lwd=0.8, col='darkgray'))
```

## Workflow type E: visualise results for the European bounding box
All the maps created with this package can be generated for a particular region.
The example below shows how to plot fwi percentiles for the European bounding box
```{r}
# Define the extent
e <- regionalBBOX(region = "Europe")
# Crop the global file to Europe's extent
croppedStack <- raster::crop(maskedMaps, e)

# In Europe the saturation is expected to be below 50, therefore we tweak the map to ignore higher values
# croppedStack[croppedStack > 50] <- NA
p <- rasterVis::levelplot(croppedStack, 
                          col.regions = rev(grDevices::heat.colors(20)),
                          colorkey = list(space = "right"), 
                          names.attr = ifiles)
# Define a background map
backgroundMap <- rworldmap::getMap(resolution = "low")
p + latticeExtra::layer(sp::sp.lines(backgroundMap, lwd=0.8, col='darkgray'))
```

## Workflow type F: visualise results for Europe only (using GFED basis regions)
The example below shows how to plot fwi percentiles for Europe using an irregular polygon provided by the basis regions (available here: www.globalfiredata.org/data.html)
```{r}
# Download one of the GFED4 files
fname <- tempfile()
download.file(url = "http://www.falw.vu/~gwerf/GFED/GFED4/GFED4.1s_1997.hdf5",
              destfile = fname)
# source("http://bioconductor.org/biocLite.R")
# biocLite("rhdf5")
library("rhdf5")
# list content
h5ls(fname)
# estract only the basis regions
basis_regions <- h5read(file = fname, name = "ancill/basis_regions")
# convert them to raster, transpose x and y, fix the extent, resample and set 0s to NA
basis_regions <- raster::raster(basis_regions)
basis_regions <- raster::t(basis_regions)
raster::extent(basis_regions) <- raster::extent(maskedMaps)
basis_regions[basis_regions == 0] <- NA
basis_regions@crs <- maskedMaps@crs
#  Reproject using the attributes of the low res raster for output
GFEDregions <- projectRaster(from = basis_regions , to = maskedMaps, method = "bilinear")
GFEDregions <- resample(GFEDregions, maskedMaps, method = "ngb")
# Plot
rasterVis::levelplot(GFEDregions)
raster::plot(GFEDregions)
# Looks good! This file is also saved in the data folder of this package
# save(GFEDregions, file = "/home/mo/moc0/Repositories/caliver/data/GFEDregions.rda")
# data("GFEDregions")

# Mask&Crop the global file to Europe's extent
maskedEurope <- raster::mask(maskedMaps, regionalMask(region = "Europe"))
croppedEurope <- raster::crop(maskedEurope, regionalBBOX(region = "Europe"))

p <- rasterVis::levelplot(croppedEurope, 
                          col.regions = rev(grDevices::heat.colors(20)),
                          colorkey = list(space = "right"))
# Define a background map
backgroundMap <- rworldmap::getMap(resolution = "low")
p + latticeExtra::layer(sp::sp.lines(backgroundMap, lwd=0.8, col='darkgray'))
```

## Workflow type G: calculate CDF by region
The first step is to get a map for a reasonable number of percentiles so that the CDF can be constructed smoothly
```{r}
# Set working directory
setwd("/var/tmp/moc0/geff/CDF")
varname <- "ffmc"

probs <- c(seq(5,95, by = 5),99)
ncfile <- paste0("/var/tmp/moc0/geff/results/", varname, "_shifted.nc")
# Calculate percentiles (globally)
listOfMaps <- getGriddedCDF(ncfile = ncfile, probs = probs)

# Define the list of regions
regions <- c("GLOB", "BONA", "TENA", "CEAM", "NHSA", "SHSA", "EURO", 
             "MIDE", "NHAF", "SHAF", "BOAS", "CEAS", "SEAS", "EQAS", "AUST")
# Then create CDF curves by averaging the percentiles over a given area
CDF <- data.frame(matrix(NA, ncol = length(regions) + 1, nrow = length(probs)))
names(CDF) <- c("percentile", regions)
CDF$percentile <- probs
data(GFEDregions)
data(fuelmodel)

for (region in regions){
  print(region)
  j <- which(names(CDF) == region) # counter over the columns
  # Mask the percentile maps using regional masks
  for (prob in probs){
    i <- which(CDF$percentile == prob)
    globalMap <- raster::raster(paste0(varname, "_shifted_", prob, ".nc"))
    globalMap_fuelonly <- raster::mask(globalMap, fuelmodel)
    if (region == "GLOB"){
      maskedMap <- globalMap_fuelonly
    }else{
      regionMap <- regionalMask(region)
      maskedMap <- raster::mask(globalMap_fuelonly, regionMap)
    }
    CDF[i, j] <- mean(as.matrix(maskedMap), na.rm=TRUE)
  }
}
saveRDS(CDF, paste0(varname, "_CDF.rds"))

library(ggplot2)
library(reshape2)
CDFmelt <- melt(data = CDF, id.vars = names(CDF)[1])
ggplot(data = CDFmelt, aes(x=value, y=percentile)) + 
  geom_line(aes(colour=variable)) + 
  ggtitle("CDF by GFED basis regions")
```

## Workflow type H: calculate thresholds by region
```{r}
# Set working directory
setwd("/var/tmp/moc0/geff/CDF")
# Define the list of regions
regions <- c("GLOB", "BONA", "TENA", "CEAM", "NHSA", "SHSA", "EURO", 
             "MIDE", "NHAF", "SHAF", "BOAS", "CEAS", "SEAS", "EQAS", "AUST")
thresholds <- data.frame(matrix(NA, ncol = 2 + length(regions), nrow = 3*4))
names(thresholds) <- c("Varname", "Potential Risk Threshold", regions)
thresholds$`Potential Risk Threshold` <- c("Low", "Medium", "High", "Extreme")
i <- 1
for (varname in c("fwi", "dc", "ffmc")){
  df <- readRDS(paste0(varname, "_CDF.rds"))
  thresholds[i:(i+3),1] <- varname
  thresholds[i,3:dim(thresholds)[2]] <- df[which(df$percentile == 50), 2:dim(df)[2]]
  thresholds[i+1,3:dim(thresholds)[2]] <- df[which(df$percentile == 75), 2:dim(df)[2]]
  thresholds[i+2,3:dim(thresholds)[2]] <- df[which(df$percentile == 90), 2:dim(df)[2]]
  thresholds[i+3,3:dim(thresholds)[2]] <- df[which(df$percentile == 99), 2:dim(df)[2]]
  i <- i + 4
}

thresholds[,3:17] <- round(thresholds[,3:17],2)
saveRDS(thresholds, "thresholds.RDS")
